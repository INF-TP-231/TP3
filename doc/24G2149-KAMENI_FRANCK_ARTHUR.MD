ğŸ§© README â€“ Bloc 5 : ImplÃ©mentation du dÃ©coupage dâ€™images

Fichier : crop.c
Auteur : Kameni Franck Arthur
Date : Octobre 2025

ğŸ¯ Objectif du module

Le fichier crop.c implÃ©mente la commande CUT, dont le rÃ´le est de dÃ©couper une sous-rÃ©gion rectangulaire dâ€™une image PPM existante pour crÃ©er une nouvelle image contenant uniquement cette zone.

Cette fonctionnalitÃ© est essentielle dans un projet de traitement dâ€™images, car elle permet de :

isoler une partie dâ€™intÃ©rÃªt (ex. un visage, un objet) ;

rÃ©duire la taille dâ€™une image avant dâ€™autres opÃ©rations ;

simplifier les traitements sur une zone spÃ©cifique.

ğŸ§  Processus de raisonnement et Ã©tapes de conception
1. Chargement de lâ€™image source

La premiÃ¨re Ã©tape consiste Ã  charger lâ€™image depuis un fichier .ppm via la fonction :

Image* img = load_ppm(filename);


Cette fonction renvoie un pointeur vers une structure Image contenant :

la largeur (width)

la hauteur (height)

la valeur maximale (max_value)

le tableau de pixels (pixels)

Une vÃ©rification immÃ©diate garantit que le chargement a rÃ©ussi ; sinon, le programme signale une erreur.

2. Validation des paramÃ¨tres dâ€™entrÃ©e

Avant de manipuler les pixels, on vÃ©rifie la validitÃ© des indices fournis :

if (l1 < 1 || l2 > img->height || l1 >= l2)
if (c1 < 1 || c2 > img->width  || c1 >= c2)


Cette Ã©tape de sÃ©curisation des bornes Ã©vite :

des accÃ¨s mÃ©moire invalides ;

des erreurs dâ€™indexation ;

la crÃ©ation dâ€™images de taille nulle ou nÃ©gative.

En cas dâ€™erreur, un message explicite prÃ©cise la contrainte correcte :

Contrainte requise : 1 <= l1 < l2 <= hauteur
Contrainte requise : 1 <= c1 < c2 <= largeur

3. Calcul des dimensions de la nouvelle image

Lâ€™image dÃ©coupÃ©e doit contenir tous les pixels compris entre les coordonnÃ©es donnÃ©es (inclusives).
La hauteur et la largeur sont donc calculÃ©es ainsi :

new_height = l2 - l1 + 1;
new_width  = c2 - c1 + 1;


Le +1 est crucial car les bornes sont inclusives (par exemple, dÃ©couper de 1 Ã  3 donne bien 3 lignes).

4. CrÃ©ation de lâ€™image rÃ©sultat

Une nouvelle image vide est allouÃ©e :

Image* cropped = create_image(new_width, new_height, img->max_value);


Cette fonction prÃ©pare la structure mÃ©moire et initialise le tableau de pixels Ã  la taille exacte du dÃ©coupage.

Si cette allocation Ã©choue, le programme libÃ¨re lâ€™image dâ€™origine et quitte proprement.

5. Copie des pixels de la rÃ©gion spÃ©cifiÃ©e

Cette partie reprÃ©sente le cÅ“ur du traitement :

for (int i = 0; i < new_height; i++) {
    for (int j = 0; j < new_width; j++) {
        int src_row = (l1 - 1) + i;
        int src_col = (c1 - 1) + j;
        cropped->pixels[i][j] = img->pixels[src_row][src_col];
    }
}


Le dÃ©calage (l1 - 1) et (c1 - 1) provient du passage dâ€™une base 1 (utilisateur) Ã  une base 0 (index mÃ©moire C).
Chaque pixel de la rÃ©gion choisie est copiÃ© dans la nouvelle image, ligne par ligne, colonne par colonne.

6. Sauvegarde et libÃ©ration mÃ©moire

Lâ€™image dÃ©coupÃ©e est enregistrÃ©e sur disque via :

save_ppm(output, cropped);


Une fois la sauvegarde terminÃ©e, les deux structures (img et cropped) sont libÃ©rÃ©es pour Ã©viter toute fuite mÃ©moire :

free_image(img);
free_image(cropped);


Le programme confirme le succÃ¨s de lâ€™opÃ©ration par :

opÃ©ration effectuÃ©e

ğŸ§© SchÃ©ma logique simplifiÃ©
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚ Image source  â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
          Charger le fichier
                  â”‚
        Valider l1, l2, c1, c2
                  â”‚
          Calculer dimensions
                  â”‚
          CrÃ©er nouvelle image
                  â”‚
         Copier pixels sÃ©lectionnÃ©s
                  â”‚
         Sauvegarder et libÃ©rer
                  â–¼
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚ Image dÃ©coupÃ©e   â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ§¾ Exemple dâ€™utilisation
cut input.ppm 50 150 30 120 output.ppm


â†’ DÃ©coupe les lignes 50 Ã  150 et les colonnes 30 Ã  120 de input.ppm
â†’ CrÃ©e une nouvelle image output.ppm